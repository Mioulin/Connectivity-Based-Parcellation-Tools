# INPUT MODALITY
modality:
  type: string
  allowed: [rsfmri, dmri, connectivity]
  required: true


# INPUT DATA
data:
  participants:
    file:
      type: string
      allowed: ['*.tsv', '*.csv', '*.xls', '*.xlsx']
      default: /path/to/file.tsv
      required: true
    delimiter:
      type: string
      default: '\t'
    index_column:
      type: string
      default: 'participant_id'
  session:
    type: 'list[string]'
    desc: 'If multiple sessions are to be used for each subject, enter the sessions as partial paths here. For
           example, [sess1, sess2] will replace the {session} wildcard used in time_series and confounds with both
           sess1 and sess2, similar to how {participant_id} is replaced with the subject-id.'
  time_series:
    type: string
    allowed: ['*.nii', '*.nii.gz']
    contains: '{participant_id}'
    default: '/path/to/{participant_id}/file.nii'
    required: true
    custom: [has_sessions]
    dependency: [modality: rsfmri]
  confounds:
    file:
      type: string
      allowed: ['*.tsv', '*.csv']
      contains: '{participant_id}'
      default: '/path/to/{participant_id}/file.tsv'
      custom: [has_sessions]
      dependency: [modality: rsfmri]
    delimiter:
      type: string
      default: '\t'
      dependency: [modality: rsfmri]
    columns:
      type: 'list[string]'
      default: []
      dependency: [modality: rsfmri]
  bet_binary_mask:
    type: string
    required: true
    allowed: ['*.nii', '*.nii.gz']
    contains: '{participant_id}'
    default: '/path/to/{participant_id}/file.nii'
    custom: [has_sessions]
    dependency: [modality: dmri]
  xfm:
    type: string
    required: true
    allowed: ['*.nii', '*.nii.gz']
    contains: '{participant_id}'
    default: '/path/to/{participant_id}/file.nii'
    custom: [has_sessions]
    dependency: [modality: dmri]
  inv_xfm:
    type: string
    required: true
    allowed: ['*.nii', '*.nii.gz']
    contains: '{participant_id}'
    default: '/path/to/{participant_id}/file.nii'
    custom: [has_sessions]
    dependency: [modality: dmri]
  samples:
    type: string
    required: true
    contains: '{participant_id}'
    default: '/path/to/{participant_id}/dir/'
    custom: [has_sessions]
    dependency: [modality: dmri]
  connectivity:
    type: string
    required: true
    allowed: ['*.npy', '*.npz']
    contains: '{participant_id}'
    default: '/path/to/{participant_id}/file.npz'
    custom: [has_sessions]
    dependency: [modality: connectivity]
  seed_coordinates:
    type: string
    required: true
    allowed: ['*.npy', '*.npz']
    default: '/path/to/seed_coordinates.npy'
    dependency: [modality: connectivity]
  masks:
    seed:
      type: string
      allowed: ['*.nii', '*.nii.gz']
      default: /path/to/file.nii
      required: true
    region_id:
      type: 'list[integer]'
      required: false
      dependency: [modality: [rsfmri, dmri], data.masks.space: standard]
    target:
      type: string
      allowed: ['*.nii', '*.nii.gz']
      dependency: [modality: [rsfmri, dmri]]
    space:
      type: string
      allowed: ['standard', 'native']
      default: standard
      required: false
      custom: [space_match]
      desc: 'If native is used, then CBPtools assumes that both seed- and target masks are in the native space of
             the individual subject. This requires {participant_id} to be present in the file path to the seed and
             target masks. Note that group results cannot be computed in native space and are therefore skipped.
             If standard is used, then the seed and target masks are assumed to be in the same group template
             space (e.g., MNI152 2mm space).'
  references:
    type: 'list[string]'
    allowed: ['*.nii', '*.nii.gz']
    required: false
    dependency: [data.masks.space: standard]
    custom: [references]


# PROCESSING PARAMETERS
parameters:
  masking:
    seed:
      binarization:
        type: float
        min: 0.0
        default: 0.0
        desc: 'Threshold above which voxels in the ROI mask image are defined as 1’s. This is only applied if the mask
                   is not binary.'
        dependency: [modality: [rsfmri, dmri]]
      median_filtering:
        apply:
          type: boolean
          default: false
          desc: 'Apply median filtering to the ROI mask'
          dependency: [modality: [rsfmri, dmri]]
        distance:
          type: integer
          min: 0
          default: 1
          desc: 'Median filtering distance'
          dependency: [modality: [rsfmri, dmri], parameters.masking.seed.median_filtering.apply: true]
      upsample_to:
        apply:
          type: boolean
          default: false
          desc: 'Upsample the seed mask to the specified voxel size (e.g., from [3, 3, 3] as 3mm isotropic to [1, 1, 1]
                       as 1mm isotropic). If left empty or as null, no upsampling will be done.'
          dependency: [modality: dmri]
        voxel_dimensions:
          type: 'list[float]'
          min: 1
          minlength: 1
          maxlength: 3
          default: [1, 1, 1]
          custom: [voxdim]
          desc: 'The voxel dimensions to which the seed mask should be upsampled.'
          dependency: [modality: dmri]
    target:
      binarization:
        type: float
        min: 0.0
        default: 0.0
        desc: 'Threshold above which voxels in the target mask image are defined as 1’s. This is only applied if the
                 mask is not binary.'
        dependency: [modality: [rsfmri, dmri]]
      remove_seed:
        apply:
          type: boolean
          default: false
          desc: 'Remove the seed voxels from the target mask.'
          dependency: [modality: [rsfmri, dmri]]
        distance:
          type: integer
          min: 0
          default: 0
          desc: 'Expand the border around the seed mask (in milimeter) for removal from the target mask. This should
                   only be applied if the input time-series data is smoothed, using the smoothing kernel as a value for
                   this parameter.'
          dependency: [modality: [rsfmri, dmri], parameters.masking.target.remove_seed.apply: true]
      subsampling:
        type: boolean
        default: true
        desc: 'Apply subsampling to the target mask to improve computational efficiency at minimal loss of specificity.
                 This removes every second voxel from the mask and is only recommended if the data has been smoothed.'
        dependency: [modality: rsfmri]
      downsample_to:
        apply:
          type: boolean
          default: false
          desc: 'Downsample the target mask to the specified voxel size, similar to how upsample_seed_to works.'
          dependency: [modality: dmri]
        voxel_dimensions:
          type: 'list[float]'
          min: 1.0
          minlength: 1
          maxlength: 3
          default: [3, 3, 3]
          custom: [voxdim]
          desc: 'The voxel dimensions to which the target mask should be downsampled.'
          dependency: [modality: dmri]

  connectivity:
    low_variance_error:
      apply:
        type: boolean
        default: true
        desc: 'When more than this specified percentage of voxels within the seed has low or no variance over the
                 entire time course, the processing for this participant will not continue. A detailed error report is
                 provided once all connectivity is processed and further processing is halted until the problems are
                 resolved.'
        dependency: [modality: rsfmri]
      in_seed:
        type: float
        min: 0.0
        max: 1.0
        default: 0.05
        desc: 'Percentage of allowed low-variance voxels occurring within the seed region.'
        dependency: [modality: rsfmri]
      in_target:
        type: float
        min: 0.0
        max: 1.0
        default: 0.1
        desc: 'Percentage of allowed low-variance voxels occurring within the target region.'
        dependency: [modality: rsfmri]
      behavior:
        type: string
        allowed: [remove, zero]
        default: zero
        desc: 'The behavior for dealing with allowed low-variance voxels. Either the entire voxel will be removed
                 (only applicable to target voxels) or they will be set to 0.'
        dependency: [modality: rsfmri]
    band_pass_filtering:
      apply:
        type: boolean
        default: false
        desc: 'Perform band-pass filtering on the signal time-series.'
        dependency: [modality: rsfmri]
      band:
        required: true
        type: 'list[float]'
        min: 0.0
        minlength: 2
        maxlength: 2
        default: [0.01, 0.08]
        custom: [bandpass]
        desc: 'High- and low-pass value for the band-pass filter. Note that if this value is set, tr should also be
                 defined.'
        dependency: [
          parameters.connectivity.band_pass_filtering.apply: true,
          modality: rsfmri
        ]
      tr:
        required: true
        type: float
        min: 0.0
        default: null
        custom: [tr]
        desc: 'Repetition time in seconds'
        dependency: [
          parameters.connectivity.band_pass_filtering.apply: true,
          modality: rsfmri
        ]
    smoothing:
      apply:
        type: boolean
        default: false
        desc: 'Apply smoothing on the signal time-series.'
        dependency: [modality: rsfmri]
      fwhm:
        type: integer
        min: 0
        default: 5
        desc: 'FWHM kernel value for smoothing.'
        dependency: [modality: rsfmri, parameters.connectivity.smoothing.apply: true]
    arctanh_transform:
      apply:
        type: boolean
        default: true
        desc: 'Arctanh transform applied to the connectivity matrix'
        dependency: [modality: rsfmri]
    pca_transform:
      apply:
        type: boolean
        default: false
        desc: 'PCA transform applied to the connectivity matrix.'
        dependency: [modality: [rsfmri, dmri]]
      components:
        type: float
        default: 0.95
        desc: 'Number of components to keep (if integer) or amount of explained variance (if float). This value is
                 equivalent to n_components in sklearn.decomposition.PCA'
        dependency: [modality: [rsfmri, dmri], parameters.connectivity.pca_transform.apply: true]
    dist_thresh:
      type: float
      min: 0.0
      default: 5.0
      desc: '(probtrackx2) Discards samples shorter than this threshold (in mm)'
      dependency: [modality: dmri]
    loop_check:
      type: boolean
      default: true
      desc: '(probtrackx2) Perform loopchecks on paths - slower, but allows lower curvature threshold'
      dependency: [modality: dmri]
    c_thresh:
      type: float
      min: 0.0
      default: 0.2
      desc: '(probtrackx2) Curvature threshold'
      dependency: [modality: dmri]
    step_length:
      type: float
      min: 0.0
      default: 0.5
      desc: '(probtrackx2) Steplength in mm'
      dependency: [modality: dmri]
    n_samples:
      type: integer
      min: 1
      default: 5000
      desc: '(probtrackx2) Number of samples'
      dependency: [modality: dmri]
    n_steps:
      type: integer
      min: 1
      default: 2000
      desc: '(probtrackx2) Number of steps per sample'
      dependency: [modality: dmri]
    correct_path_distribution:
      type: boolean
      default: true
      desc: '(probtrackx2) Correct path distribution for the length of the pathways'
      dependency: [modality: dmri]
    cubic_transform:
      apply:
        type: boolean
        default: true
        desc: 'Apply a cubic transformation on the connectivity matrix'
        dependency: [modality: dmri]
    cleanup_fsl:
      type: boolean
      default: true
      desc: 'Remove all files created by probtrackx2 (except fdt_matrix2.dot) after the connectivity matrix has been
                 extracted.'
      dependency: [modality: dmri]
  clustering:
    method:
      type: string
      allowed: [kmeans, spectral, agglomerative]
      default: kmeans
      desc: 'Clustering method to be used, either kmeans, spectral, or agglomerative'
    n_clusters:
      type: 'list[integer]'
      min: 2
      minlength: 1
      default: []
      required: true
      desc: 'A list of cluster numbers to be evaluated (entered as [2, 3, 8] to receive a 2, 3, and 8-cluster
             solution)'
    cluster_options:
      # k-means options
      algorithm:
        dependency: [parameters.clustering.method: kmeans]
        type: string
        allowed: [auto, full, elkan]
        default: auto
        desc: '(sklearn.cluster.KMeans) K-means algorithm to use'
      init:
        dependency: [parameters.clustering.method: kmeans]
        type: string
        allowed: [k-means++, random]
        default: k-means++
        desc: '(sklearn.cluster.KMeans) Method for initialization'
      max_iter:
        dependency: [parameters.clustering.method: kmeans]
        type: integer
        min: 1
        default: 10000
        desc: '(sklearn.cluster.KMeans) Maximum number of iterations of the k-means algorithm for a single run.'
      n_init:
        dependency: [parameters.clustering.method: [kmeans, spectral]]
        type: integer
        min: 1
        default: 256
        desc: '(sklearn.cluster.KMeans or sklearn.cluster.SpectralClustering) Number of time the k-means algorithm
               will be run with different centroid seeds.'

      # Spectral clustering options
      kernel:
        dependency: [parameters.clustering.method: spectral]
        type: string
        allowed: [additive_chi2, chi2, linear, polynomial, rbf, laplacian, sigmoid, cosine, nearest_neighbors]
        default: nearest_neighbors
        custom: [spectral_kernel]
        desc: '(sklearn.cluster.SpectralClustering; affinity) Kernel to be used.'
      gamma:
        dependency: [
          parameters.clustering.method: spectral,
          parameters.clustering.cluster_options.kernel: [rbf, polynomial, sigmoid, laplacian, chi2]
        ]
        type: float
        min: 0.0
        desc: '(sklearn.cluster.SpectralClustering) Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2
               kernels. Ignored for affinity=nearest_neighbors.'
      n_neighbors:
        required: true
        dependency: [
          parameters.clustering.method: spectral,
          parameters.clustering.cluster_options.kernel: nearest_neighbors
        ]
        default: 10
        type: integer
        min: 1
        desc: '(sklearn.cluster.SpectralClustering) Number of neighbors to use when constructing the affinity matrix
               using the nearest neighbors method.'
      assign_labels:
        dependency: [parameters.clustering.method: spectral]
        type: string
        allowed: [kmeans, discretize]
        default: kmeans
        desc: '(sklearn.cluster.SpectralClustering) The strategy to use to assign labels in the embedding space.'
      degree:
        dependency: [
          parameters.clustering.method: spectral,
          parameters.clustering.cluster_options.kernel: polynomial
        ]
        type: float
        min: 0.0
        default: 3.0
        desc: '(sklearn.cluster.SpectralClustering) Degree of the polynomial kernel.'
      coef0:
        dependency: [
          parameters.clustering.method: spectral,
          parameters.clustering.cluster_options.kernel: [polynomial, sigmoid]
        ]
        type: float
        min: 0.0
        default: 1.0
        desc: '(sklearn.cluster.SpectralClustering) Zero coefficient for polynomial and sigmoid kernels'
      eigen_tol:
        dependency: [
          parameters.clustering.method: spectral,
          parameters.clustering.cluster_options.eigen_solver: arpack
        ]
        type: float
        min: 0.0
        default: 1.e-10
        desc: '(sklearn.cluster.SpectralClustering) Stopping criterion for eigendecomposition of the Laplacian matrix
               when eigen_solver="arpack"'
      eigen_solver:
        dependency: [parameters.clustering.method: spectral]
        type: string
        default: null
        allowed: [null, arpack, lobpcg, amg]
        desc: '(sklearn.cluster.SpectralClustering) The eigenvalue decomposition strategy to use. AMG requires pyamg
               to be installed'

      # Agglomerative clustering options
      distance_metric:
        dependency: [parameters.clustering.method: agglomerative]
        type: string
        allowed: [euclidean, l1, l2, manhattan, cosine]
        default: euclidean
        desc: '(sklearn.cluster.AgglomerativeClustering; affinity) Metric to compute the linkage. If linkage is
               "ward", only "euclidean" is accepted.'
      linkage:
        dependency: [parameters.clustering.method: agglomerative]
        type: string
        allowed: [ward, complete, average, single]
        default: ward
        custom: [agglomerative_linkage]
        desc: '(sklearn.cluster.AgglomerativeClustering) Which linkage criterion to use.'

    grouping:
      linkage:
        type: string
        allowed: [complete, average, single]
        default: complete
        desc: '(scipy.cluster.hierarchy.linkage) The linkage algorithm to use'
      method:
        type: string
        allowed: [mode, agglomerative]
        default: mode
        desc: 'Method for obtaining group-level clustering results'
    validity:
      internal:
        type: 'list[string]'
        allowed: [silhouette_score, davies_bouldin_score, calinski_harabasz_score]
        default: [silhouette_score]
        desc: 'List of internal validity metrics to assess'
      similarity:
        type: string
        allowed: [adjusted_rand_score, adjusted_mutual_info_score, v_measure_score]
        default: adjusted_rand_score
        desc: 'Similarity metric to use to generate between-subject cluster comparisons and subject to group-level
               cluster comparisons'
  report:
    figure_format:
      type: string
      allowed: [png, svg, pdf, ps, eps]
      default: png
      desc: 'Format of the output figures generated for the summary'
    individual_plots:
      type: boolean
      default: false
      dependency: [data.masks.space: standard]
      desc: 'Provide cluster-labeled ROI voxel plots for each individual subjects'
    benchmark:
      type: boolean
      default: false
      custom: [benchmarking]
      desc: 'benchmark the execution of each workflow task'
    compress_output:
      type: boolean
      default: true
      desc: 'Compress interim output (i.e., NIfTI images and NumPy arrays) to reduce the file size. This comes at the
             cost of slower processing speed.'
