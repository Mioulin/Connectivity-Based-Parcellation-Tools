modality:
  type: string
  allowed: [rsfmri, dmri, connectivity]
  required: true

schema-general:
  data:
    participants:
      file:
        type: string
        allowed: ['*.tsv', '*.csv', '*.xls', '*.xlsx']
        default: /path/to/file.tsv
        required: true
      delimiter:
        type: string
        default: '\t'
      index_column:
        type: string
        default: 'participant_id'
    seed_mask:
      type: string
      allowed: ['*.nii', '*.nii.gz']
      default: /path/to/file.nii
      required: true

  parameters:
    clustering:
      n_clusters:
        type: 'list[integer]'
        min: 2
        minlength: 1
        default: []
        required: true
        desc: 'A list of cluster numbers to be evaluated (entered as [2, 3, 8] to receive a 2, 3, and 8-cluster
               solution)'
      kmeans:
        algorithm:
          type: string
          allowed: [auto, full, elkan]
          default: auto
          desc: '(sklearn.cluster.KMeans) K-means algorithm to use'
        init:
          type: string
          allowed: [k-means++, random]
          default: k-means++
          desc: '(sklearn.cluster.KMeans) Method for initialization'
        max_iter:
          type: integer
          min: 1
          default: 10000
          desc: '(sklearn.cluster.KMeans) Maximum number of iterations of the k-means algorithm for a single run.'
        n_init:
          type: integer
          min: 1
          default: 256
          desc: '(sklearn.cluster.KMeans) Number of time the k-means algorithm will be run with different centroid
                 seeds.'
      grouping:
        linkage:
          type: string
          allowed: [complete, average, single]
          default: complete
          desc: '(scipy.cluster.hierarchy.linkage) The linkage algorithm to use'
        method:
          type: string
          allowed: [mode, agglomerative]
          default: mode
          desc: 'Method for obtaining group-level clustering results'
      validity:
        internal:
          type: 'list[string]'
          allowed: [silhouette_score, davies_bouldin_score, calinski_harabasz_score]
          default: [silhouette_score]
          desc: 'List of internal validity metrics to assess'
        similarity:
          type: string
          allowed: [adjusted_rand_score, adjusted_mutual_info_score, v_measure_score]
          default: adjusted_rand_score
          desc: 'Similarity metric to use to generate between-subject cluster comparisons and subject to group-level
                 cluster comparisons'
    report:
      figure_format:
        type: string
        allowed: [png, svg, pdf, ps, eps]
        default: png
        desc: 'Format of the output figures generated for the summary'


schema-connectivity:
  data:
    connectivity:
      type: string
      required: true
      allowed: ['*.npy', '*.npz']
      contains: '{participant_id}'
      default: '/path/to/{participant_id}/file.npz'
    seed_coordinates:
      type: string
      required: true
      allowed: ['*.npy', '*.npz']
      default: '/path/to/seed_coordinates.npy'

schema-rsfmri:
  data:
    time_series:
      type: string
      allowed: ['*.nii', '*.nii.gz']
      contains: '{participant_id}'
      default: '/path/to/{participant_id}/file.nii'
      required: true
    confounds:
      file:
        type: string
        allowed: ['*.tsv', '*.csv']
        contains: '{participant_id}'
        default: '/path/to/{participant_id}/file.tsv'
      delimiter:
        type: string
        default: '\t'
      columns:
        type: 'list[string]'
        default: []
    target_mask:
      type: string
      allowed: ['*.nii', '*.nii.gz']

  parameters:
    mask_preproc_seed:
      binarization:
        type: float
        min: 0.0
        default: 0.0
        desc: 'Threshold above which voxels in the ROI mask image are defined as 1’s. This is only applied if the mask
               is not binary.'
      median_filtering:
        apply:
          type: boolean
          default: false
          desc: 'Apply median filtering to the ROI mask'
        distance:
          type: integer
          min: 0
          default: 1
          desc: 'Median filtering distance'
    mask_preproc_target:
      binarization:
        type: float
        min: 0.0
        default: 0.0
        desc: 'Threshold above which voxels in the target mask image are defined as 1’s. This is only applied if the
               mask is not binary.'
      remove_seed:
        apply:
          type: boolean
          default: false
          desc: 'Remove the seed voxels from the target mask.'
        distance:
          type: integer
          min: 0
          default: 0
          desc: 'Expand the border around the seed mask (in milimeter) for removal from the target mask. This should
                 only be applied if the input time-series data is smoothed, using the smoothing kernel as a value for
                 this parameter.'
      subsampling:
        type: boolean
        default: true
        desc: 'Apply subsampling to the target mask to improve computational efficiency at minimal loss of specificity.
               This removes every second voxel from the mask and is only recommended if the data has been smoothed.'
    time_series_proc:
      low_variance_error:
        apply:
          type: boolean
          default: true
          desc: 'When more than this specified percentage of voxels within the seed has low or no variance over the
                 entire time course, the processing for this participant will not continue. A detailed error report is
                 provided once all connectivity is processed and further processing is halted until the problems are
                 resolved.'
        in_seed:
          type: float
          min: 0.0
          max: 1.0
          default: 0.05
          desc: 'Percentage of allowed low-variance voxels occurring within the seed region.'
        in_target:
          type: float
          min: 0.0
          max: 1.0
          default: 0.1
          desc: 'Percentage of allowed low-variance voxels occurring within the target region.'
        behavior:
          type: string
          allowed: [remove, zero]
          default: zero
          desc: 'The behavior for dealing with allowed low-variance voxels. Either the entire voxel will be removed
                 (only applicable to target voxels) or they will be set to 0.'
      band_pass_filtering:
        apply:
          type: boolean
          default: false
          desc: 'Perform band-pass filtering on the signal time-series.'
        band:
          type: 'list[float]'
          min: 0.0
          minlength: 2
          maxlength: 2
          default: [0.01, 0.08]
          custom: [bandpass]
          desc: 'High- and low-pass value for the band-pass filter. Note that if this value is set, tr should also be
                 defined.'
        tr:
          type: float
          min: 0.0
          default: null
          custom: [tr]
          desc: 'Repetition time in seconds'
      smoothing:
        apply:
          type: boolean
          default: false
          desc: 'Apply smoothing on the signal time-series.'
        fwhm:
          type: integer
          min: 0
          default: 5
          desc: 'FWHM kernel value for smoothing.'
      arctanh_transform:
        apply:
          type: boolean
          default: true
          desc: 'Arctanh transform applied to the connectivity matrix'
      pca_transform:
        apply:
          type: boolean
          default: false
          desc: 'PCA transform applied to the connectivity matrix.'
        components:
          type: float
          default: 0.95
          desc: 'Number of components to keep (if integer) or amount of explained variance (if float). This value is
                 equivalent to n_components in sklearn.decomposition.PCA'
      compress:
        type: boolean
        default: true
        desc: 'Compress the connectivity matrix output to compressed .npz files instead of uncompressed .npy files.
               This will save disk space but processing will be slightly slower.'


schema-dmri:
  data:
    target_mask:
      type: string
      allowed: ['*.nii', '*.nii.gz']
    bet_binary_mask:
      type: string
      required: true
      allowed: ['*.nii', '*.nii.gz']
      contains: '{participant_id}'
      default: '/path/to/{participant_id}/file.nii'
    xfm:
      type: string
      required: true
      allowed: ['*.nii', '*.nii.gz']
      contains: '{participant_id}'
      default: '/path/to/{participant_id}/file.nii'
    inv_xfm:
      type: string
      required: true
      allowed: ['*.nii', '*.nii.gz']
      contains: '{participant_id}'
      default: '/path/to/{participant_id}/file.nii'
    samples:
      type: string
      required: true
      contains: '{participant_id}'
      default: '/path/to/{participant_id}/dir/'

  parameters:
    mask_preproc_seed:
      binarization:
        type: float
        min: 0.0
        default: 0.0
        desc: 'Threshold above which voxels in the ROI mask image are defined as 1’s. This is only applied if the mask
               is not binary.'
      median_filtering:
        apply:
          type: boolean
          default: false
          desc: 'Apply median filtering to the ROI mask'
        distance:
          type: integer
          min: 0
          default: 1
          desc: 'Median filtering distance'
      upsample_to:
        apply:
          type: boolean
          default: false
          desc: 'Upsample the seed mask to the specified voxel size (e.g., from [3, 3, 3] as 3mm isotropic to [1, 1, 1]
                 as 1mm isotropic). If left empty or as null, no upsampling will be done.'
        voxel_dimensions:
          type: 'list[float]'
          min: 1
          minlength: 1
          maxlength: 3
          default: [1, 1, 1]
          custom: [voxdim]
          desc: 'The voxel dimensions to which the seed mask should be upsampled.'
    mask_preproc_target:
      binarization:
        type: float
        min: 0.0
        default: 0.0
        desc: 'Threshold above which voxels in the target mask image are defined as 1’s. This is only applied if the
               mask is not binary.'
      remove_seed:
        apply:
          type: boolean
          default: false
          desc: 'Remove the seed voxels from the target mask.'
        distance:
          type: integer
          min: 0
          default: 0
          desc: 'Expand the border around the seed mask (in milimeter) for removal from the target mask. This should
                 only be applied if the input time-series data is smoothed, using the smoothing kernel as a value for
                 this parameter.'
      downsample_to:
        apply:
          type: boolean
          default: false
          desc: 'Downsample the target mask to the specified voxel size, similar to how upsample_seed_to works.'
        voxel_dimensions:
          type: 'list[float]'
          min: 1.0
          minlength: 1
          maxlength: 3
          default: [3, 3, 3]
          custom: [voxdim]
          desc: 'The voxel dimensions to which the target mask should be downsampled.'
    probtract_proc:
      dist_thresh:
        type: float
        min: 0.0
        default: 5.0
        desc: '(probtrackx2) Discards samples shorter than this threshold (in mm)'
      loop_check:
        type: boolean
        default: true
        desc: '(probtrackx2) Perform loopchecks on paths - slower, but allows lower curvature threshold'
      c_thresh:
        type: float
        min: 0.0
        default: 0.2
        desc: '(probtrackx2) Curvature threshold'
      step_length:
        type: float
        min: 0.0
        default: 0.5
        desc: '(probtrackx2) Steplength in mm'
      n_samples:
        type: integer
        min: 1
        default: 5000
        desc: '(probtrackx2) Number of samples'
      n_steps:
        type: integer
        min: 1
        default: 2000
        desc: '(probtrackx2) Number of steps per sample'
      correct_path_distribution:
        type: boolean
        default: true
        desc: '(probtrackx2) Correct path distribution for the length of the pathways'
      cubic_transform:
        apply:
          type: boolean
          default: true
          desc: 'Apply a cubic transformation on the connectivity matrix'
      pca_transform:
        apply:
          type: boolean
          default: false
          desc: 'PCA transform applied to the connectivity matrix.'
        components:
          type: float
          default: 0.95
          desc: 'Number of components to keep (if integer) or amount of explained variance (if float). This value is
                 equivalent to n_components in sklearn.decomposition.PCA'
      compress:
        type: boolean
        default: true
        desc: 'Compress the connectivity matrix output to compressed .npz files instead of uncompressed .npy files.
               This will save disk space but processing will be slightly slower.'
      cleanup_fsl:
        type: boolean
        default: true
        desc: 'Remove all files created by probtrackx2 (except fdt_matrix2.dot) after the connectivity matrix has been
               extracted.'

